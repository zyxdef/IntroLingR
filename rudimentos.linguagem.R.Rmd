---
title: "Rudimentos da Linguagem R"
author: "Marcelo Ventura Freire (EACH/USP)"
output:
    ioslides_presentation:
        widescreen : true
        self_contained: true
        smart: true
---

```{r setup, include=FALSE, eval=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```



## O que veremos

1. [Tipos e Estruturas de Dados em R](#5)
1. [Programação em R](#117)



## O que veremos

1. Tipos e Estruturas de Dados em R 
    1. [Tipos de Dados](#6)
    1. [Estruturas de Dados](#30)
    1. [Atributos](#85)
    1. [“Não-dados”](#107)
1. Programação em R



## O que veremos

1. Tipos e estruturas de dados em R 
1. Programação em R
    1. [*Scripts*](#119)
    1. [Comentários](#122)
    1. [Funções](#125)
    1. [Operadores de Atribuição](#157)
    1. [Operadores de Indexação](#163)
    1. [Operações e Funções Matemáticas](#250)
    1. [Operações e Funções de Comparação](#266)
    1. [Operações e Funções Lógicas](#270)
    1. [Instruções de Repetições](#277)
    1. [Instruções de Execução Condicional](#302)





# Tipos e Estruturas de Dados em R 





# Tipos de Dados



## Tipos de Dados

1. Quantitativo, 
2. Textual, 
3. Lógico, 
4. Categórico
5. Outros



## Quantitativo

O R consegue lidar números

- inteiros (*integer*)
    - `1L`, `10L`, `-5L`
- reais (*double*)
    - `1`, `10`, `10.0`, `-10.5`
- complexos (*complex*)
    - `1 + 0i`, `2 + 3i`, `1i`

Valores numéricos são *double* por padrão, a menos que explicitado outro tipo.



## Quantitativo

```{r 1, eval=FALSE}
2
2L
2 + 0i
```



## Quantitativo

```{r 1}
```



## Quantitativo

```{r 1a, eval=FALSE}
2 + 3
2L + 3L
log(3.4)
log(3.4 + 0i)
```



## Quantitativo

```{r 1a}
```



## Textual

O R consegue lidar com informações textuais

```{r 2, eval=FALSE}
'Isto é um texto'
"Isto também"
paste("Nós somos", "três textos,", "mas vamos virar um só!")
```



## Textual

O R consegue lidar com informações textuais

```{r 2}
```



## Lógico

O R consegue lidar com valores lógicos: 

- verdadeiro (`TRUE` ou `T`) 
- falso (`FALSE` ou `F`)

```{r 3, eval=FALSE}
2 < 3
x <- (2 < 3)
x
```



## Lógico

O R consegue lidar com valores lógicos: 

- verdadeiro (`TRUE` ou `T`) 
- falso (`FALSE` ou `F`)

```{r 3}
```



## Categórico 

O R consegue lidar com dados qualitativos 

- nominais (através da função `factor()`)
- ordinais (através da função `ordered()`)

Dados categóricos são mais do que apenas textos em R.

Eles têm metainformação, que os dados textuais não têm.

        Fatores = Dados + Metadados



## Categórico 

### **Importante**

Rotina como `aov()` (que realiza ANOVA) exigem que variáveis qualitativas tenham
sido armazenadas como fatores.

Se você tentar executar `aov()` com uma regressora quantitativa, vai ser 
retornada a tabela de ANOVA da regressão linear ao invés da tabela de ANOVA da 
análise de variância

        Depois não diga que eu não avisei...



## Categórico 

```{r 4, eval=FALSE}
c("criança", "adulto", "idoso")     # só texto
factor(c("criança", "adulto", "idoso"))     # fator
```



## Categórico 

```{r 4}
```



## Categórico 

```{r 4a, eval=FALSE}
observações <- c(3, 2, 1, 3, 2)
categs <- c("criança", "adulto", "idoso")
factor(observações, levels = 1:3, labels = categs)
ordered(observações, levels = 1:3, labels = categs)
```



## Categórico 

```{r 4a}
```

Note as categorias



## Categórico 

```{r 4b, eval=FALSE}
observações <- c(3, 2, 1, 3, 2)
categs <- c("criança", "adulto", "idoso")
factor(observações, levels = 1:3, labels = categs, ordered = T)
ordered(observações, levels = 1:3, labels = categs)
```



## Categórico 

```{r 4b}
```

A mesma coisa



## Categórico 

```{r 4c, eval=FALSE}
ordered(c("criança", "adulto", "idoso"))
categs <- c("criança", "adulto", "idoso")
ordered(c("criança", "adulto", "idoso"), levels = categs)
```



## Categórico 

```{r 4c}
```

O primeiro está errado (salvo situações excepcionais; note as categorias), mas 
o segundo está certo.



## Outros Tipos de "Dados"

Por incrível que pareça, o R consegue tratar código executável como dado.



## Outros Tipos de "Dados"

Por exemplo, já vimos 

```{r}
x <- 2
typeof(x)
x <- "A"
typeof(x)
```



## Outros Tipos de "Dados"

Mas isto é novidade

```{r}
x <- factor("A")
typeof(x)
x <- factor
typeof(x)
```

O primeiro é um dado categórico, mas o tipo do segundo é a própria função que 
precisamos executar para conseguir um dado categórico (identificado como 
`closure` pelo R).





# Estruturas de Dados



## Estruturas de Dados

1. Vetorial (`c()`, `vector()`), 
2. Lista/“dicionário” (`list()`), 
3. Matricial (`matrix()` e `array()`),
4. Conjunto de dados (`data.frame()`)



## Vetores 

Por padrão, os dados no R são vetores (*atomic vectors*)

```{r}
2 + 2
```

Esse `[1]` antes do resultado é a posição (primeira) do valor `4` dentro do 
vetor de comprimento unitário que é o resultado da operação acima.



## Vetores 

A função `c()` gera vetores.

```{r 5, eval=FALSE}
c(1, 3, 3, 7)
```



## Vetores 

A função `c()` gera vetores.

```{r 5}
```



## Vetores 

A função `c()` também junta e "achata" múltiplos vetores em um único vetor.

```{r 5a, eval=FALSE}
c(c(1, 2, 3, 4), c(5, 6, 7, 8))
```



## Vetores 

A função `c()` também junta e "achata" múltiplos vetores em um único vetor.

```{r 5a}
```



## Vetores 

O operador `:` gera sequências.

```{r 5b, eval=FALSE}
1:10
1:40
```



## Vetores 

O operador `:` gera sequências.

```{r 5b}
```

O `[24]` na segunda linha do resultado de `1:40` 
é um lembrete que o valor `24` ocupa a 24^a^ posição do resultado da operação.



## Vetores 

```{r 5c, eval=FALSE}
-1:10
-1:-10
-(1:10)
-10:-1
```



## Vetores 

```{r 5c}
```



## Vetores 

Os dados de um vetor **têm** que ser do mesmo tipo.

Se não forem, o R converte todos para um mesmo tipo que os comporte através de 
*regras de coerção*.

```{r 5d, eval=FALSE}
c(1, 2, 3, 4)
c(1, 2, 3, 4, "A")
```



## Vetores 

Os dados de um vetor **têm** que ser do mesmo tipo.

Se não forem, o R converte todos para um mesmo tipo que os comporte através de 
*regras de coerção*.

```{r 5d}
```



## Vetores 

Os dados de um vetor **têm** que ser do mesmo tipo.

Se não forem, o R converte todos para um mesmo tipo que os comporte através de 
*regras de coerção*.

```{r 5e, eval=FALSE}
typeof(c(1L, 2L, 3L, 4L)); typeof(c(1, 2L, 3L, 4L))
```



## Vetores 

Os dados de um vetor **têm** que ser do mesmo tipo.

Se não forem, o R converte todos para um mesmo tipo que os comporte através de 
*regras de coerção*.

```{r 5e}
```



## Vetores 

Os dados de um vetor **têm** que ser do mesmo tipo.

Se não forem, o R converte todos para um mesmo tipo que os comporte através de 
*regras de coerção*.

```{r 5f, eval=FALSE}
c(1L, 2, 3 + 0i)
c(1L, 2, 3 + 0i, "A")
```



## Vetores 

Os dados de um vetor **têm** que ser do mesmo tipo.

Se não forem, o R converte todos para um mesmo tipo que os comporte através de 
*regras de coerção*.

```{r 5f}
```



## Listas

Informalmente, as listas podem ser pensadas como vetores que comportam dados de 
diferentes tipos sem que eles sejam forçados a terem o mesmo tipo em comum.

```{r 6a, eval=FALSE}
list(1, 2)
list(1, "a")
```



## Listas

Informalmente, as listas podem ser pensadas como vetores que comportam dados de 
diferentes tipos sem que eles sejam forçados a terem o mesmo tipo em comum.

```{r 6a}
```

Esse `[[2]]` indica que a 2^a^ posição da lista é ocupada por um vetor.

O `[1]` seguinte indica que a 1^a^ posição desse vetor é o valor `2` 
apresentado.



## Listas

É possível aninhar listas dentro de listas.

```{r 6b, eval=FALSE}
list(list(1, 2), c(1, 2))
```



## Listas

É possível aninhar listas dentro de listas.

```{r 6b}
```



## Listas

É possível dar nomes aos elementos de uma lista.

```{r 6c, eval=FALSE}
list(x = 1, y = 2, tipo = "novo")
```



## Listas

É possível aninhar listas dentro de listas.

```{r 6c}
```



## Listas

```{r 6d, eval=FALSE}
list(list(list(1, 2), 3))
```


## Listas

```{r 6d}
```



## Listas

Mas dá para "achatar" a lista em um vetor
```{r 6e, eval=FALSE}
unlist(list(list(list(1, 2), 3)))
unlist(list(x = 1, y = 2, tipo = "novo"))
```



## Listas

Mas dá para "achatar" a lista em um vetor
```{r 6e}
```



## Matrizes e *Arrays*

Matrizes podem ser pensadas como vetores com duas "direções" e *arrays* como 
vetores com várias "direções".

```{r 7, eval=FALSE}
matrix(c(1, 2, 3, 4), nrow = 2)
matrix(1:8, nrow = 2)
```



## Matrizes e *Arrays*

Matrizes podem ser pensadas como vetores com duas "direções" e *arrays* como 
vetores com várias "direções".

```{r 7}
```



## Matrizes e *Arrays*

Matrizes podem ser pensadas como vetores com duas "direções" e *arrays* como 
vetores com várias "direções".

```{r 7a, eval=FALSE}
array(1:12, dim = c(2, 3, 2))
```



## Matrizes e *Arrays*

Matrizes podem ser pensadas como vetores com duas "direções" e *arrays* como 
vetores com várias "direções".

```{r 7a}
```



## Matrizes e *Arrays*

Na verdade, vetores são *arrays* unidimensionais e matrizes são *arrays* 
bidimensionais.

```{r 7b, eval=FALSE}
array(1:4, dim = c(4))
array(1:4, dim = c(2,2))
```



## Matrizes e *Arrays*

Na verdade, vetores são *arrays* unidimensionais e matrizes são *arrays* 
bidimensionais.

```{r 7b}
```



## Matrizes e *Arrays*

Por motivos históricos, as matrizes são preenchidas no R por colunas ao invés 
de ser por linhas, mas isso pode ser mudado.

```{r 7c, eval=FALSE}
matrix(1:9, nrow = 3)
matrix(1:9, nrow = 3, byrow = T)
```



## Matrizes e *Arrays*

Por motivos históricos, as matrizes são preenchidas no R por colunas ao invés 
de ser por linhas, mas isso pode ser mudado.

```{r 7c}
```



## Matrizes e *Arrays*

Assim, como os vetores, os valores de uma matriz e *array* têm que ser do mesmo 
tipo ou então eles são forçados por regras de coreção.

```{r 7d, eval=FALSE}
array(c(1, 2, 3, "A"), dim = c(2,2))
```



## Matrizes e *Arrays*

Assim, como os vetores, os valores de uma matriz e *array* têm que ser do mesmo 
tipo ou então eles são forçados por regras de coreção.

```{r 7d}
```



## *Data Frames*

No R, o típico conjunto de dados é um *data frame*.

Criamos um *data frame* com a função `data.frame()` 

```{r 8, eval=FALSE}
data.frame(
    nome = c("Ana", "Bia", "Ciro"), 
    idade = c(20, 22, 27),
    sexo = factor(c("f", "f", "m"))
)
```



## *Data Frames*

No R, o típico conjunto de dados é um *data frame*.

Criamos um *data frame* com a função `data.frame()` 

```{r 8}
```



## *Data Frames*

Os argumentos de `data.frame()` são as variáveis (colunas) do conjunto de dados 
e os seus nomes podem ser dados através dos nomes dos argumentos passados.

Todos os argumentos de `data.frame()` devem ser vetores com o mesmo comprimento,
correspondendo ao número de observações no conjunto de dados



## *Data Frames*

```{r 8a, eval=FALSE}
conjdados <- 
    data.frame(
        nome = c("Ana", "Bia", "Ciro"), 
        idade = c(20, 22, 27),
        sexo = factor(c("f", "f", "m"))
    )
conjdados
```



## *Data Frames*

```{r 8a}
```



## *Data Frames*

Um *data frame* pode ser tratado como lista e também como matriz.

- aceita `[]` com um vetor de inteiros ou de strings e retorna um *data frame*
(que nem uma lista)
- aceita `[[]]` com um inteiro ou string e retorna um vetor (que nem uma lista)
- aceita `[ , ]` com um par de vetores de inteiros ou de strings e retorna um 
*data frame* (que nem uma matriz)



## *Data Frames*

```{r 8b, eval=FALSE}
conjdados[1] # data frame
conjdados[1:2] # data frame
```



## *Data Frames*

```{r 8b}
```



## *Data Frames*

```{r 8c, eval=FALSE}
conjdados[1] # data frame
conjdados[[1]] # vetor
```



## *Data Frames*

```{r 8c}
```



## *Data Frames*

```{r 8d, eval=FALSE}
conjdados[1] # data frame
conjdados[1, 1] # vetor
```



## *Data Frames*

```{r 8d}
```



## *Data Frames*

```{r 8e, eval=FALSE}
conjdados[1, 1] # vetor
conjdados[1:2, 1:2] # data frame
```



## *Data Frames*

```{r 8e}
```



## *Data Frames*

```{r 8f, eval=FALSE}
conjdados[1:2, 1] # vetor
conjdados[1:2, 1:2] # data frame
```



## *Data Frames*

```{r 8f}
```



## *Data Frames*

```{r 8g, eval=FALSE}
conjdados[1:2, 1] # vetor
conjdados[1:2, "Nome"] # vetor
```



## *Data Frames*

```{r 8g}
```





# Atributos



## Atributos

As metainformações dos tipos de dados e das estruturas de dados são armazenados 
na forma de atributos.

1. `attributes()` e `str()`
1. `names()`, 
2. `levels()` e `nlevels()`
3. `dim()` e `dimnames()` 
4. `rownames()` e `colnames()`
5. `ncols()` e `nrows()`



## `attributes()` e `str()`

```{r 9, eval=FALSE}
attributes(conjdados)
```



## `attributes()` e `str()`

```{r 9}
```



## `attributes()` e `str()`

```{r 9a, eval=FALSE}
str(conjdados)
```



## `attributes()` e `str()`

```{r 9a}
```



## `names()`

```{r 9b, eval=FALSE}
names(conjdados)
names(conjdados) <- c("Nome", "Idade", "Sexo")
conjdados
```



## `names()`

```{r 9b}
```



##  `levels()` e `nlevels()`

```{r 9c, eval=FALSE}
grupo.etário <- 
    ordered(c(3, 2, 1, 3, 2), 
            levels = 1:3, 
            labels = c("criança", "adulto", "idoso"))
grupo.etário
```



##  `levels()` e `nlevels()`

```{r 9c}
```



## `levels()` e `nlevels()`

```{r 9d, eval=FALSE}
levels(grupo.etário)
nlevels(grupo.etário)
```



## `levels()` e `nlevels()`

```{r 9d}
```



## `levels()` e `nlevels()`

```{r 9e, eval=FALSE}
levels(grupo.etário) <- c("CRI", "ADU", "IDO")
grupo.etário
```



## `levels()` e `nlevels()`

```{r 9e}
```



## `levels()` e `nlevels()`

```{r 9f, eval=FALSE}
levels(grupo.etário) <- c("criança", "adulto", "idoso", "imortal")
grupo.etário
nlevels(grupo.etário)
```



## `levels()` e `nlevels()`

```{r 9f}
```



## `dim()` e `dimnames()` 

```{r 9g, eval=FALSE}
dim(conjdados)
dimnames(conjdados)
```



## `dim()` e `dimnames()` 

```{r 9g}
```



## `rownames()` e `colnames()`

```{r 9h, eval=FALSE}
rownames(conjdados)
colnames(conjdados)
```




## `rownames()` e `colnames()`

```{r 9h}
```



## `ncols()` e `nrows()`

```{r 9i, eval=FALSE}
ncol(conjdados)
nrow(conjdados)
```



## `ncols()` e `nrows()`

```{r 9i}
```





# “Não-Dados” do R



## Os “Não-Dados” do R

1. Dado faltante (*missing*): `NA` -- *Not Available*
2. Dado não numérico: `NaN` -- *Not a Number*
3. Valor Infinito: `Inf`
4. Ausência de valor: `NULL`



## Dado Faltante

```{r 10, eval=FALSE}
idades <- c(18, 28, NA, 32)
idades
log(idades)
```



## Dado Faltante

```{r 10}
```



## Dado Não Numérico

```{r 10a, eval=FALSE}
idades <- c(18, 28, -2, 32)
idades
log(idades)
```



## Dado Não Numérico

```{r 10a}
```



## Valor Infinito

```{r 10b, eval=FALSE}
idades <- c(18, 28, 0, 32)
idades
log(idades)
```



## Valor Infinito

```{r 10b}
```



## Ausência de Valor

```{r 10c, eval=FALSE}
c()
```



## Ausência de Valor

```{r 10c}
```





# Programação em R



## Programação em R

1. *Scripts*
1. Comentários
1. Funções
1. Operadores de atribuição
2. Operadores de indexação
5. Operações e funções matemáticas
5. Operações e funções de comparação
5. Operações e funções lógicas
3. Instruções de repetição
4. Instruções de execução condicional





# *Scripts*



## *Scripts*

Em R, tudo é uma expressão e, nesse sentido, o próprio R é apenas uma grande
calculadora, que lê expressões e as avalia, retornando um valor ou objeto.

Chamamos de ***script*** ou **programa** o arquivo de texto que contém o 
conjunto de operações e expressões em R a serem realizadas no seu conjunto de 
dados e que resultarão em tabelas, gráficos ou resultados.

Esse arquivo é geralmente identificado pelas extensões `.R` ou `.r`



## *Scripts*

O comando `source("calcula.R")` executa o *script* que está armazenado no 
diretório ou pasta atual com o nome `analise.R`.

```{r}
writeLines(readLines("calcula.R"))
source("calcula.R")
```

O R lê e avalia sequencialmente as operações que estão no arquivo `calcula.R`.





# Comentários



## Comentários

É possível armazenar informações importantes sobre o seu *script* dentro do seu 
próprio *script*, de modo que você consiga lembrar quando você precisar no 
futuro quando você já tiver esquecido.

Para isso, basta colocar o símbolo `#` em qualquer ponto do seu *script*, que o 
R ignorará tudo o que estiver escrito do símbolo `#` até o final da linha.

```{r}
print("Isto será impresso")  # mas isto aqui sequer será avaliado pelo R
```



## Comentários

**DICA**

**DOCUMENTE O SEU *SCRIPT* COM COMENTÁRIOS**

**SEMPRE**

É sério.

Seis meses após você ter escrito o seu programa (tipo, quando você estiver 
escrevendo a sua monografia, dissertação ou tese...), você **NÃO VAI LEMBRAR** 
por que catzo você fez as escolhas que você fez.




# Funções



## Funções em R

Em R, é possível criar um objeto que realiza uma mesma sequência de operações 
fixas com um conjunto de objetos do R quaisquer que você indique.

Chamamos esse tipo de objeto uma **função**.

Uma função pode recebe como **argumentos** ou **parâmetros** um certo número de 
objetos, realiza operações e pode retornar um objeto como resultado das 
operações realizadas.



## Funções em R

Por exemplo, a função `log()` recebeu um argumento numérico 10 e retornou o 
valor do logaritmo neperiano (i.e., de base *e*=2.718281828) do seu argumento

```{r 11, eval=FALSE}
log(10)
```



## Funções em R

Por exemplo, a função `log()` recebeu um argumento numérico 10 e retornou o 
valor do logaritmo neperiano (i.e., de base *e*=2.718281828) do seu argumento

```{r 11}
```



## Funções em R

A função `log()` também poderia ter recebido dois argumentos 
numéricos: o valor cujo logaritmo é desejado e a *base* desejada do logaritmo.

```{r 11a, eval=FALSE}
log(10, 10)
log(10, 2)
```



## Funções em R

A função `log()` também poderia ter recebido dois argumentos 
numéricos: o valor cujo logaritmo é desejado e a *base* desejada do logaritmo.

```{r 11a}
```



## Usando Funções Existentes

Como já vimos, para executar uma função existente, fazemos uma referência ao seu
nome seguido de parênteses cercando os argumentos da função (caso haja).

Caso avaliemos apenas o nome da função *sem* os parênteses, o objeto é retornado
e veremos o código da função.

```{r 11b, eval=FALSE}
log       #  isto não é uma chamada à função logarítmica
log(10)   # já isto sim, pois há os parênteses
```



## Usando Funções Existentes

Como já vimos, para executar uma função existente, fazemos uma referência ao seu
nome seguido de parênteses cercando os argumentos da função (caso haja).

Caso avaliemos apenas o nome da função *sem* os parênteses, o objeto é retornado
e veremos o código da função.

```{r 11b}
```



## Usando Funções Existentes

Note que os argumentos de `log()` têm nomes e que `log()` tem um valor padrão 
para o argumento `base`, caso esse argumento seja omitido, mas não tem um valor
padrão para o argumento `x`.

Casos os nomes sejam omitidos, os argumentos são avaliados na ordem em que 
aparecem, mas se os nomes estiverem presentes, a ordem com a qual aparecem não 
importa.



## Usando Funções Existentes

```{r 11c, eval=FALSE}
log(10, 2)
log(x = 10, base = 2)
log(base = 2, x = 10)
```



## Usando Funções Existentes

```{r 11c}
```



## Usando Funções Existentes

Se omitíssemos o argumento `x`, que não tem um valor padrão para o caso de 
omissão, receberíamos uma mensagem do R

```{r 11d, eval=FALSE}
log()
log(base = 10)
```



## Usando Funções Existentes

Se omitíssemos o argumento `x`, que não tem um valor padrão para o caso de 
omissão, receberíamos uma mensagem do R

```{r 11d, error=TRUE}
```



## Usando Funções Existentes

Para descobrir quais parâmetros têm valor padrão e quais não, podemos usar o 
*help* (no caso de funções dos pacotes) ou ver a definição da função

```{r 11e, eval=FALSE}
log
```



## Usando Funções Existentes

Para descobrir quais parâmetros têm valor padrão e quais não, podemos usar o 
*help* (no caso de funções dos pacotes) ou ver a definição da função

```{r 11e}
```

Note que `base` é seguido de `=exp(1)` (que é o seu valor padrão), ao passo que
`x` não.

Na prática, um parâmetro com valor padrão é um parâmetro opcional da função.



## Criando as suas Próprias Funções

Você cria uma função usando `function` seguido de parênteses e de uma expressão 
que será avaliada toda vez que a função for chamada e será retornada como o 
valor da função.

```{r, eval=FALSE}
f <- function() return(expressão)
```

ou simplesmente

```{r, eval=FALSE}
f <- function() expressão 
```

Essa expressão é chamada de **corpo** da função.



## Criando as suas Próprias Funções

Se você quiser que sua função receba um ou mais argumentos para serem utilizados
no corpo da função, você deve incluí-los entre os parênteses após `function`.

```{r 11f, eval=FALSE}
f <- function(x) x + 2
g <- function(x, y) x * y / 2
f(5)
g(3, 7)
```



## Criando as suas Próprias Funções

Se você quiser que sua função receba um ou mais argumentos para serem utilizados
no corpo da função, você deve incluí-los entre os parênteses após `function`.

```{r 11f}
```



## Criando as suas Próprias Funções

Se chamar a função com mais ou menos argumentos do que a função espera receber, 
você receberá uma mensagem de erro.

```{r 11g, eval=FALSE}
f(5, 3)
g(2)
```



## Criando as suas Próprias Funções

Se chamar a função com mais ou menos argumentos do que a função espera receber, 
você receberá uma mensagem de erro.

```{r 11g, error = TRUE}
```



## Criando as suas Próprias Funções

Se você escolher definir um valor padrão para um argumento na definição da 
função, então ele pode ser omitido sem erro quando a função for executada.

```{r 11h, eval=FALSE}
g <- function(x, y = 7) x * y / 2
g(3, 7)
g(3)
```



## Criando as suas Próprias Funções

Se você escolher definir um valor padrão para um argumento na definição da 
função, então ele pode ser omitido sem erro quando a função for executada.

```{r 11h}
```



## Criando as suas Próprias Funções

Você pode precisar realizar várias operações intermediárias antes de chegar ao 
resultado que você pretende retornar na sua função.  

Nesse caso, é possível executar essas várias operações dentro da função 
(inclusive criando variáveis temporárias, que serão descartadas após o término 
da execução da função) e retornar apenas o resultado da última expressão 
executada ou o resultado da expressão passada para o `return()`.



## Criando as suas Próprias Funções

Basta envolver entre chaves `{}` o conjunto de expressões a serem consideradas 
como o corpo da função.

Para separar as expressões do corpo da função (dentro do `{}`), basta deixar 
cada expressão em uma linha separada.

```{r}
g <- function(x) {
    print(summary(x))
    hist(x)
    sum((x ^ 2) * log(x + 3))
}
```



## Criando as suas Próprias Funções

```{r 11i, eval=FALSE}
g(c(2,3,1,4,3,5,3,4,5,3,4))
```



## Criando as suas Próprias Funções

```{r 11i, fig.height = 2, fig.width = 2}
```



## Criando as suas Próprias Funções

Se for o caso, é possível deixar mais de uma expressão na mesma linha, desde que 
separadas por ponto e vírgula `;`.

```{r}
g <- function(x) {print(summary(x)); hist(x); sum((x ^ 2) * log(x + 3))}
```



## Criando as suas Próprias Funções

Caso uma expressão fique muito grande para ficar em uma única linha, 
basta pular para a linha seguintes ***desde que*** o R perceba que a expressão 
ainda não acabou, como, por exemplo, 

```{r 11j, eval=FALSE}
h <- function(x) {             # o R continua lendo na próxima linha, 
                             # pois falta o corpo da função
    x ^ 3 + 2 * x ^ 2 +       # idem, pois falta um valor após o +
    30 * x - 50 * x ^ (1 / 2) # acabou
}
h(2)
```



## Criando as suas Próprias Funções

Caso uma expressão fique muito grande para ficar em uma única linha, 
basta pular para a linha seguintes ***desde que*** o R perceba que a expressão 
ainda não acabou, como, por exemplo, 

```{r 11j}
```



## Criando as suas Próprias Funções

Além de definir o valor de retorno, `return()` também encerra a execução da 
função e volta para a chamada da função ao invés de executar o restante do corpo
da função.

```{r}
h <- function(x) {
    if (x >= 0)
        return(x)
    else
        return(-x)
}
```



## Criando as suas Próprias Funções

Se você não quiser retornar valor nenhum, simplesmente use `return()` sem nada 
dentro dos parênteses.

```{r 11k, eval=FALSE}
h <- function(x) {
    hist(x)
    return()
}
h(c(2,5,3,5,7,4,6,7,3,6,4,5,3,5,3,5,4,2,4))
```



## Criando as suas Próprias Funções

Se você não quiser retornar valor nenhum, simplesmente use `return()` sem nada 
dentro dos parênteses.

```{r 11k, fig.height=2, fig.width=3}
```



# Operadores de Atribuição



## Operadores de Atribuição

Como já vimos, o operador `<-` associa um objeto a um *nome válido*.



## O que é um *nome válido* em `R`?

Um nome válido no `R` é uma sequência de um ou mais caracteres tais que:

1. o primeiro caracter pode ser uma letra ou o símbolo `"."` (ponto)
1. o segundo caracter (se houver) pode ser uma letra, o símbolo `"."` (ponto) 
ou o símbolo `"_"` (sublinhado)
    - se o primeiro caracter não for `"."` (ponto), o segundo caracter também 
    poderá ser um dígito
1. do terceiro caracter em diante (se houver), ele pode ser letra, dígito ou os 
símbolos `"."` e `"_"` 



## O que é um *nome válido* em `R`?

O `R` entende por *letra* tanto os caracteres latinos não acentuados (de 
`"A"` a `"Z"` e de `"a"` a `"z"`) como 

- caracteres latinos acentuados (como `"Á"`, `"ç"`, `"ä"`, `"ŷ"`, `"ñ"` 
etc.), 
- caracteres de alfabetos não latinos (como `"я"` do alfabeto cirílico, `"θ"` 
do alfabeto grego, `"男"` do alfabeto chinês etc.)

*Scripts* com esses caracteres terão problema de portabilidade: um *script* que 
funciona na sua máquina pode não funcionar na máquina de outra pessoa.

***Conselho***: por precaução, só use caracteres latinos não acentuados 
(de `A` a `Z` e de `a` a `z`) e não use nomes como `男` em um *script*.


## Operadores de Atribuição

- O `R` considera como diferentes a versão maiúscula e a versão minúscula das 
letras.
    - Assim, `"X"` e `"x"` são nomes diferentes, da mesma forma como são nomes 
    diferentes `"opção"`, `"Opção"`, `"OPÇÃO"` e `"OpÇãO"`.

***Conselho***: Apesar de ser possível, prefira não usar `"."` como nome.

- Há diversos motivos para esse conselho.



## Operadores de Atribuição

Exemplos de nomes válidos:

- `x`, `y`, `x1`, `x.1`, `x_1`, `x2.3_a.z`
- `compensação`, `é`
- `opçãomenu`, `opção.menu`, `opçãoMenu`

Exemplos de nómes inválidos:

- `1a.escolha` -- começa por um dígito
- `.2a.escolha` -- começa por ponto seguido de dígito
- `_3a.escolha` -- começa por sublinhado
- `1L` -- na verdade, é um número inteiro
- `opção-2` -- o `R` compreende como a diferença entre `opção` e 2



## Operadores de Atribuição

Exemplos de nomes válidos **escrotos**:

- `x2.3_a.z`
- `.__...____....._____.......`

***Conselho***: Não use nomes escrotos assim; imagine este código:

```{r, eval=FALSE}
._ + .._.. ^ ._.._... * ._._(...._, ......._)
```



## Operadores de Atribuição

Além do operador `<-`, há também o operador `->`

```{r 12, eval=FALSE}
x <- 2
2 -> y
x == y
```



## Operadores de Atribuição

Além do operador `<-`, há também o operador `->`

```{r 12}
```





# Operadores de Indexação



## Operadores de Indexação

1. Os operadores `[]`, `[[]]` e `$`
2. Indexando nas linhas e nas colunas
3. Indexando com vetores numéricos positivos e negativos 
4. Indexando com vetores lógicos 
5. Indexando com vetores textuais
6. A opção `drop = F` do operador `[]`



## Operador `[]`

O operador `[]` pode ser usado de várias formas

- com vetor
- com matriz
- com *array*
- com lista
- com *data frame*



## Operador `[]` com vetor

```{r 13a, eval=FALSE}
dado <- 1:10
dado
dado[2] 
dado[c(2, 5)]
```



## Operador `[]` com vetor

```{r 13a}
```



## Operador `[]` com matriz

```{r 13b, eval=FALSE}
dado <- matrix(1:9, ncol = 3)
dado
dado[1] # retorna elemento
dado[4] 
```



## Operador `[]` com matriz

```{r 13b}
```



## Operador `[]` com matriz

```{r 13c, eval=FALSE}
dado[1:4]  # retorna elementos
dado[1, 1] # retorna elemento
dado[1, 2] 
dado[2, 1] 
```



## Operador `[]` com matriz

```{r 13c}
```



## Operador `[]` com matriz

```{r 13d, eval=FALSE}
dado[2:3, 1:2] # retorna matriz
dado[2, ] # retorna linha como vetor
dado[, 1] # retorna coluna como vetor
```



## Operador `[]` com matriz

```{r 13d}
```



## Operador `[]` com matriz

### Opção `drop = FALSE`

As expressões `dado[2, ]` e `dado[, 1]` retornaram dois vetores, ao invés de 
terem retornado matrizes 1*x*3 e 3*x*1 respectivamente.

Isso ocorreu porque, por padrão, o operador `[]` descarta a estrutura se o 
resultado da expressão for uma matriz linha ou matriz coluna.

Para evitar esse comportamento padrão, podemos usar a opção `drop = FALSE` do 
operador `[]`



## Operador `[]` com matriz

### Opção `drop = FALSE`

```{r 13e, eval=FALSE}
dado[2, ] # retorna linha como vetor
dado[2, , drop = F] # retorna matriz
```



## Operador `[]` com matriz

### Opção `drop = FALSE`

```{r 13e}
```



## Operador `[]` com matriz

### Opção `drop = FALSE`

```{r 13f, eval=FALSE}
dado[, 1] # retorna coluna como vetor
dado[, 1, drop = F] # retorna matriz
```



## Operador `[]` com matriz

### Opção `drop = FALSE`

```{r 13f}
```



## Operador `[]` com *array*

```{r 13g, eval=FALSE}
tensor <- 
    array(1:8, dim = c(2,2,2))
tensor
```



## Operador `[]` com *array*

```{r 13g}
```



## Operador `[]` com *array*
```{r 13h, eval=FALSE}
tensor[1, 1, 1] # retorna elemento
tensor[1, 1, 2]
tensor[1, 2, 1]
tensor[2, 1, 1]
```



## Operador `[]` com *array*
```{r 13h}
```



## Operador `[]` com *array*
```{r 13i, eval=FALSE}
tensor[1, 1, ] # retorna vetor
tensor[1, , 1]
tensor[, 1, 1]
```



## Operador `[]` com *array*
```{r 13i}
```



## Operador `[]` com *array*

Opção `drop = FALSE`

Da mesma forma que para matrizes, o operador `[]` também descarta a estrutura 
por padrão se o resultado for um *array* unidimensional.

Também aqui, é possível usar a opção `drop = FALSE`



## Operador `[]` com *array*

Opção `drop = FALSE`

```{r 13j, eval=FALSE}
tensor[1, 1, , drop = F] # retorna array
```



## Operador `[]` com *array*

Opção `drop = FALSE`

```{r 13j}
```



## Operador `[]` com *array*

Opção `drop = FALSE`

```{r 13k, eval=FALSE}
tensor[1, , 1, drop = F] # retorna array
```



## Operador `[]` com *array*

Opção `drop = FALSE`

```{r 13k}
```



## Operador `[]` com *array*

Opção `drop = FALSE`

```{r 13l, eval=FALSE}
tensor[, 1, 1, drop = F] # retorna array
```



## Operador `[]` com *array*

Opção `drop = FALSE`

```{r 13l}
```



## Operador `[]` com *array*

```{r 13m, eval=FALSE}
tensor[1, , ] # retorna matriz
tensor[, 1, ]
tensor[, , 1]
```



## Operador `[]` com *array*

```{r 13m}
```



## Operador `[]` com *array*

```{r 13n, eval=FALSE}
tensor[1, , ] # retorna matriz
tensor[1] # retorna elemento
tensor[1, ] # dá erro
```



## Operador `[]` com *array*

```{r 13n, error=TRUE}
```



## Operador `[]` com lista

```{r 13o, eval=FALSE}
lista <- list(1, 2, 3)
lista
```



## Operador `[]` com lista

```{r 13o}
```



## Operador `[]` com lista

```{r 13p, eval=FALSE}
lista[1] # retorna lista
lista[1:2] # retorna lista
lista[c(1, 2)] # o mesmo resultado
```



## Operador `[]` com lista

```{r 13p}
```



## Operador `[]` com lista

Aqui, `drop = FALSE` não surte efeito algum.

```{r 13q, eval=FALSE}
lista[c(1, 2)]
lista[c(1, 2), drop = F]
```



## Operador `[]` com lista

Aqui, `drop = FALSE` não surte efeito algum.

```{r 13q}
```



## Operador `[]` com lista

```{r 13r, eval=FALSE}
lista[c(1, 2)] # retorna lista
lista[1, 2] # dá erro
```



## Operador `[]` com lista

```{r 13r, error=TRUE}
```



## Operador `[]` com lista

Nem mesmo com

```{r 13s, eval=FALSE}
lista <- list(list(1, 2), list(1, 2))
lista
lista[1, 2]
```



## Operador `[]` com lista

Nem mesmo com

```{r 13s, error=TRUE}
```






## Operador `[]` com lista

Nem mesmo com

```{r 13s1, eval=FALSE}
lista[1, 2]
```



## Operador `[]` com lista

Nem mesmo com

```{r 13s1, error=TRUE}
```



## Operador `[]` com lista

```{r 13t, eval=FALSE}
lista[1, 2] # dá erro
lista[1] # retorna lista
```



## Operador `[]` com lista

```{r 13t, error=TRUE}
```



## Operador `[]` com *data frame*

```{r 13v, eval=FALSE}
conjdados # retorna data frame
conjdados[1, 1] # retorna vetor de fator 
conjdados[3, 2] # retorna vetor numérico 
```



## Operador `[]` com *data frame*

```{r 13v}
```



## Operador `[]` com *data frame*

```{r 13w, eval=FALSE}
conjdados[1] # retorna data frame
conjdados[1, ] # retorna data frame
conjdados[, 1] # retorna vetor
conjdados[1, 1] # retorna vetor
```



## Operador `[]` com *data frame*

```{r 13w}
```



## Operador `[]` com *data frame*

```{r 13x, eval=FALSE}
conjdados[1] # retorna data frame
conjdados[, 1] # retorna vetor
```



## Operador `[]` com *data frame*

```{r 13x}
```



## Operador `[]` com *data frame*

```{r 13y, eval=FALSE}
conjdados[1] # retorna um data frame
conjdados["Nome"] # a mesma coisa
```



## Operador `[]` com *data frame*

```{r 13y}
```



## Operador `[]` com *data frame*

### Opção `drop`

A opção `drop = F` funciona com *data frames* também.

Apesar de existe uma opção `drop = T`, ela não exerce o efeito esperado e apenas
faz um mensagem de aviso ser emitida.



## Operador `[]` com *data frame*

### Opção `drop`

```{r 13z, eval=FALSE}
conjdados[, "Nome"] 
conjdados[, "Nome", drop = F] # funciona como esperado
```



## Operador `[]` com *data frame*

### Opção `drop`

```{r 13z}
```



## Operador `[]` com *data frame*

### Opção `drop`

```{r 13aa, eval=FALSE}
conjdados["Nome"]
conjdados["Nome", drop = T]  # NÃO funciona como esperado
```



## Operador `[]` com *data frame*

### Opção `drop`

```{r 13aa}
```



## Operador `[]` com *data frame*

```{r 13ab, eval=FALSE}
conjdados[, 1] # retorna um vetor de fatores
conjdados[, "Nome"] # a mesma coisa
```



## Operador `[]` com *data frame*

```{r 13ab}
```



## Operador `[[]]`

O operador `[[]]` pode ser usado com 

- listas
- *data frames*



## Operador `[[]]` com lista

```{r 14a, eval=FALSE}
lista <- list(x = 1:5, y = 2:10, z = 3:9)
lista
lista[[1]] # retorna um elemento
```



## Operador `[[]]` com lista

```{r 14a}
```



## Operador `[[]]` com lista

```{r 14b, eval=FALSE}
lista <- list(x = list(1,2), y = 2:10, z = 3:9)
lista
```



## Operador `[[]]` com lista

```{r 14b}
```



## Operador `[[]]` com lista

```{r 14c, eval=FALSE}
lista[[1]] # retorna um elemento (que é uma lista)
lista[[c(1,2)]] # retorna o elemento da lista retornada acima
```



## Operador `[[]]` com lista

```{r 14c}
```



## Operador `[[]]` com lista

Compare

```{r 14d, eval=FALSE}
lista[c(1,2)] 
lista[[c(1,2)]] 
```



## Operador `[[]]` com lista

```{r 14d}
```



## Operador `[[]]` com *data frame*

```{r 14e, eval=FALSE}
conjdados[[1]]
conjdados[["Nome"]]
```



## Operador `[[]]` com *data frame*

```{r 14e}
```



## Operador `$`

Funciona tanto com lista como com *data frame*.

```{r 15a, eval=FALSE}
lista$y
conjdados$Nome
```



## Operador `$`

Funciona tanto com lista como com *data frame*.

```{r 15a}
```



## Operador `$`

Compare

```{r 15b, eval=FALSE}
lista[["y"]]
lista$y
```



## Operador `$`

Compare

```{r 15b}
```



## Operador `$`

Compare

```{r 15c, eval=FALSE}
conjdados[["Nome"]]
conjdados$Nome
```



## Operador `$`

Compare

```{r 15c}
```



## Indexando com vetores numéricos negativos 

Ao utilizar o operador `[]` com vetores de inteiros negativos, obtemos como 
resultado a estrutura de dados **sem** as posições informadas.



## Indexando com vetores numéricos negativos 

```{r 16, eval=FALSE}
idades <- c(20, 23, 18, 39, 32, 27, 19, 35)
idades
idades[-c(3, 2, 5, 7)] # sem os 2o, 3o, 5o e 7o elementos
idades[-1:-5] # sem os elementos 1o a 5o
```



## Indexando com vetores numéricos negativos 

```{r 16}
```



## Indexando com vetores lógicos 

Ao utilizar o operador `[]` com vetores de lógicos, obtemos como 
resultado a estrutura de dados **com** as posições correspondentes a `TRUE` e 
**sem** as posições correspondentes a `FALSE` no vetor lógico.

O vetor usado como índice **precisa** necessariamente ter as mesmas dimensões 
que a estrutura de dados.



## Indexando com vetores lógicos 

```{r 17a, eval=FALSE}
idades[c(T, T, F, F, T, F, F, T)] # 8 elementos
conjdados[c(T, F, T), "Nome"] # 3 linhas
conjdados[c(T, F, T), c(F, T)] # 3 linhas e 2 colunas
```



## Indexando com vetores lógicos 

```{r 17a}
```



## Indexando com vetores lógicos 

Se o vetor índice não tiver as mesmas dimensões da estrutura de dados, poderão 
ou não ocorrer erros.

```{r 17b, eval=FALSE}
idades[c(T, T, F, F)] # idade tem 8 elementos
idades[c(T, T, F, F, T, T, F, F, T, T, F, F)] # idade tem 8 elementos
```



## Indexando com vetores lógicos 

```{r 17b, error=TRUE}
```

No primeiro caso, o vetor índice foi "reciclado": se `indice` for igual ao vetor
`c(T, T, F, F)`, então `idades[indice]` virará `idades[c(indice,indice)]`.

No segundo caso, o vetor índice avançou para além do fim da estrutura de dados, 
resultando nos `NA`s observados.





# Operadores e Funções Matemáticas
## Operadores Matemáticos

1. `+` -- adição
1. `-` -- subtração
1. `*` -- produto escalar
1. `/` -- divisão real
1. `^` ou `**` -- potência
1. `%%` -- resto de divisão
1. `%/%` -- divisão inteira
1. `%*%` -- produto interno
1. `%o%` -- produto externo



## Operações Matemáticas

No R, todas as operações foram pensadas para serem realizadas com vetores

```{r}
2 + 2
c(1,2,3,4) * c(10, 20, 30, 40)
(1:5) ^ 2
```



## Um parênteses: Operadores Binários em Geral

O R pode ser bastante complacente com as operações entre vetores.

Quando as dimensões dos dois vetores não coincidem, o R "recicla" o menor 
vetor quantas vezes for necessário para dar conta do vetor maior.

```{r}
c(1, 2, 3, 4, 5, 6) + c(2, 3, 4)
c(1, 2, 3, 4, 5, 6, 7, 8, 9) + c(2, 3, 4)
```



## Um parênteses: Operadores Binários em Geral

Contudo, se o comprimento do maior vetor não for um múltiplo do comprimento do 
menor vetor, o R realiza a operação do mesmo jeito, mas sinaliza a discrepância 
através de uma mensagem de aviso.

```{r, warning=TRUE}
c(1, 2, 3, 4, 5) + c(2, 3, 4)
```



## Operações Matemáticas

Note a importância dos parênteses

```{r}
(1:5) ^ 2
1:5 ^ 2
```

Na segunda expressão, a operação `^` é realizada antes da operação `:`.





## Operações Matemáticas

Note a diferença entre `/`, `%/%` e `%%`

```{r}
2:10 / 2
2:10 %/% 2
2:10 %% 2
```



## Operações Matemáticas

Note a diferença entre os três operadores de multiplicação `*`, `%*%` e `%o%`

```{r}
1:3 * 1:3
1:3 %*% 1:3
1:3 %o% 1:3
```



## Funções Matemáticas

Boa parte das funções matemáticas básicas estão disponíveis no R e são 
vetorizadas.

1. Função exponencial `exp()` 
1. Funções logaritmicas `log()`, `log10()` e `log2()`
1. Funções gerais `abs()`, `sign()` e `sqrt()`
1. Funções de arredondamento/truncamento: `floor()`, `ceiling()`, `trunc()`, 
`round()`, `signif()`
1. Outras Funções
    1. Funções trigonométricas: `cos`, `sin`, `tan`, `acos`, `asin`, `atan`
    1. Funções hiperbólicas: `cosh`, `sinh`, `tanh`, `acosh`, `asinh`, `atanh`



## Funções Matemáticas

```{r}
exp(1:3)
log(1:3)
abs(-2:2)
sign(-2:2)
```



## Funções Matemáticas

```{r}
floor((-10:10)/10)
ceiling((-10:10)/10)
trunc((-10:10)/10)
round((-10:10)/10)
```



## Funções Matemáticas

```{r}
(1:4)/3
signif((1:4)/3, 1)
signif((1:4)/3, 2)
signif((1:4)/3, 3) # digitos significativos != casas decimais
```



## Funções Matemáticas

```{r}
(1:4)/3
round((1:4)/3, 1)
round((1:4)/3, 2)
round((1:4)/3, 3)
```



## Operações e Funções Matemáticas

Na verdade, cada operador é um atalho conveniente para uma função

```{r}
2 + 2
sum(2, 2)
```



## Operações e Funções Matemáticas

Na verdade, cada operador é um atalho conveniente para uma função

```{r}
`+`
sum
```

## Operações e Funções Matemáticas

Note que o \` (*backtick*, aspa simples reversa ou tique) serve para fazer 
referência ao símbolo `+`.  Sem ele, o R daria erro por falta dos valores a 
serem somados.

```{r}
`+`
```

```{r, error=TRUE}
+
```





# Operações e Funções de Comparação



## Operações e Funções de Comparação

1. `<` -- menor que
1. `<=` -- menor que ou igual a
1. `>` -- maior que
1. `>=` -- maior que ou igual a
1. `==` -- igual a
1. `!=` -- diferente de 
1. `%in%` -- pertence a 



## Operações e Funções de Comparação

```{r}
1:10 < 5
1:10 <= 5
1:10 > 5
1:10 >= 5
```



## Operações e Funções de Comparação

```{r}
1:10 == 5
1:10 != 5
1:10 %in% c(2, 3, 5, 7, 9, 11, 13)
```



## Operações e Funções de Comparação

Infelizmente, uma expressão tal como 
```{r, eval=FALSE}
20 <= idades <= 30
```
não retornaria 
```{r, echo=FALSE}
20 <= idades & idades <= 30
```
como esperado, mas sim
```{r, error=TRUE}
20 <= idades <= 30
```



## Operações e Funções de Comparação

Por que isso ocorre?

Porque `21 <= idades <= 25` na verdade precisaria ser 
```{r}
21 <= idades & idades <= 25
```
como veremos na próxima seção.





# Operações e Funções Lógicas



## Operações e Funções Lógicas

1. `!` -- negação lógica
1. `&` -- operador lógico "E" vetorial
1. `&&` -- operador lógico "E" atômico
1. `|` -- operador lógico "OU" vetorial
1. `||` -- operador lógico "OU" atômico
1. `xor()` -- operador lógico "OU exclusivo" vetorial
1. `any()` -- retorna `TRUE` se algum valor for `TRUE` e `FALSE` caso contrário
1. `all()` -- retorna `TRUE` se todos os valores forem `TRUE` e `FALSE` caso 
contrário



## Operações e Funções Lógicas

```{r}
!c(T, F)
c(T, T, F, F) & c(T, F, T, F)
c(T, T, F, F) | c(T, F, T, F)
xor(c(T, T, F, F), c(T, F, T, F))
```



## Operações e Funções Lógicas

A diferença entre os operadores de comparação vetoriais e os atômicos

```{r}
c(T, T, F, F) & c(T, F, T, F)
c(T, T, F, F) && c(T, F, T, F)
```



## Operações e Funções Lógicas

```{r, eval=FALSE}
vetor1 && vetor2
```
é a mesma coisa que 
```{r, eval=FALSE}
vetor1[1] & vetor2[1]
```
e 
```{r, eval=FALSE}
vetor1 || vetor2
```
é a mesma coisa que
```{r, eval=FALSE}
vetor1[1] | vetor2[1]
```



## Operações e Funções Lógicas

```{r}
any(c(T, F))
all(c(T, F))
```



## Voltando ao exemplo "`20 <= idades <= 30`"

Como vimos, `20 <= idades` e `idades <= 30` retornam um vetor lógico cada um, 
os quais são combinados posição a posição pelo operador lógico `&` vetorial

```{r}
idades
20 <= idades; idades <= 30; 20 <= idades & idades <= 30
```





# Ordem de Precedência



## Ordem de Precedência

Ordem decrescente de precedência entre operadores

|                       |                                          |
|:----------------------+:-----------------------------------------|
| 1) `$`                |   8) `+` e `-` binários                  |
| 2) `[]` e `[[]]`      |   9) `<`, `>`, `<=`, `>=`, `==` e `!=`   |
| 3) `^`                |  10) `!`                                 |
| 4) `-` e `+` unários  |  11) `&` e `&&`                          |
| 5) `:`                |  12) `|` e `||`                          |
| 6) `%%` e `%/%`^1^    |  13) `->`                                |
| 7) `*` e `/`          |  14) `<-`                                |

^1^ Na verdade, entram nesse nível de precedência todos os operadores que 
começam com e terminam em `%`, como o `%>%`, que veremos mais a diante no curso.


## Exemplos de aplicação

```{r}
idades
idades < 30
idades[idades < 30]
```



## Exemplos de aplicação

```{r}
conjdados[conjdados$Idade < 25, c("Nome", "Sexo")]
```





# Instruções de Repetição



## Instruções de Repetição (*Loop*)

1. A instrução `for`
    1. `1:N`, 
    2. `names()`
    3. `seq()`
2. *As instruções `while`, `repeat`, `break` e `next`*



## Instrução `for`

A instrução `for` serve para repetir um trecho de código quantas vezes for 
necessário.

A sintaxe da instrução `for` é

```{r, eval=FALSE}
for (variável in sequência) expressão
```

Se houver mais de a expressão, use `{}`

```{r, eval=FALSE}
for (variável in sequência) {expressão; ...; expressão}
```



## Instrução `for`

Quebrar a instrução em mais de uma linha geralmente aumenta a legibilidade do 
seu código.

```{r, eval=FALSE}
for (variável in sequência) 
    expressão

for (variável in sequência) {
    expressão
    ...
    expressão
}
```



## Instrução `for`

É possível executar este código ...

```{r}
for (i in 1:3) print(idades[i])
```



## Instrução `for`

... ao invés deste

```{r}
print(idades[1])
print(idades[2])
print(idades[3])
```



## Instrução `for`

Claro, esse foi um exemplo bobinho, pois poderíamos ter executado

```{r}
print(idades[1:3])
```



## Exemplo de Aplicação

Mas este exemplo não é tão bobinho

```{r}
for (nome in names(conjdados))
    print(class(conjdados[[nome]]))
```



## Exemplo de Aplicação

Isso é curioso, pois `conjdados` foi definido como

```{r, eval=FALSE}
conjdados <- 
    data.frame(
        nome = c("Ana", "Bia", "Ciro"), 
        idade = c(20, 22, 27),
        sexo = factor(c("f", "f", "m"))
    )
```

e, depois, mudamos os nomes da variáveis para

```{r, eval=FALSE}
names(conjdados) <- c("Nome", "Idade", "Sexo")
```

mas não mudamos o tipo de `Nome` de textual (`character`) para categórico 
(`factor`).



## Exemplo de Aplicação

Por que a primeira variável é categórica ao invés de texto?

Por causa da sintaxe de `data.frame`

```{r}
data.frame # para ver o corpo da função
```



## Exemplo de Aplicação

Tem muito...

```{r}
args(data.frame) # para ver apenas os argumentos da função
```

Agora sim, podemos ver que `data.frame` tem vários parâmetros e que 
`stringsAsFactors` tem por valor padrão 
o resultado da função `default.stringsAsFactors()`, que é

```{r}
default.stringsAsFactors()
```



## Exemplo de Aplicação

Ou seja, `data.frame()` automaticamente converte vetores de texto em fatores.

Para evitar esse comportamento padrão, `conjdados` deveria ter sido definido com

```{r 18}
conjdados <- 
    data.frame(
        nome = c("Ana", "Bia", "Ciro"), 
        idade = c(20, 22, 27),
        sexo = factor(c("f", "f", "m")),
        stringsAsFactors = FALSE
    )
```



## Exemplo de Aplicação

Agora sim

```{r}
for (nome in names(conjdados))
    print(class(conjdados[[nome]]))
```



## Exemplo de Aplicação

Por fim, note utilizamos `conjdados[[nome]]` dentro de `class()` ao invés de 
`conjdados[nome]`.

`conjdados[nome]` não teria retornado vetores, mas sim a mesma estrutura de 
`conjdados`.  

```{r}
for (nome in names(conjdados))
    print(class(conjdados[nome]))
```

Veremos mais sobre isso adiante no curso.



## Instrução `for`

Na verdade, podemos usar todo tipo de estrutura (vetor, lista, matriz, *array* 
ou *data frame*) dentro de um `for` ou qualquer função que retorne uma 
estrutura.

Por exemplo, aqui

```{r}
for (variavel in conjdados)
    print(class(variavel))
```

literalmente os vetores que compõem as colunas de `conjdados` são os valores 
que `variavel` assume em cada iteração do *loop*.



## Instrução `for`

Interessante para usar com `for`:

1. `seq()`
1. `names()`



## Instrução `for`

### Função `seq()`

1. `seq(num1, num2)` 
    - o mesmo que `num1:num2`
1. `seq(num1, num2, num3)`
    - é tipo `num1:num2`, mas pulando de `num3` em `num3`
1. `seq(num1, num2, length.out = num3)`
    - é tipo `num1:num2`, mas com `num3` termos
1. `seq(estrutura)`
    - o mesmo que `1:length(estrutura)`



## Instrução `for`

### Função `seq()`

```{r}
seq(10, 20)
seq(10, 20, 2)
seq(10, 20, length.out = 3)
```



## Instrução `for`

### Função `seq()`

```{r}
idades
seq(idades)
```



## Instrução `for`

### Função `seq()`

Note a diferença

```{r}
seq(1, 20, 3) # os termos não ultrapassam 20
seq(1, 20, length.out = 3) # ajusta o salto para dar 3 termos
```



## Outras Instruções de *Loop*

Existem outras instruções referentes a *loop* em R, cumpre falar sobre elas,
mas **eu** desaconselho vocês as usarem até terem mais experiência com R.

1. `while`
1. `repeat`
1. `break`
1. `next`



## Outras Instruções de *Loop*

1. `while`
    - `while(`*condição*`)` *expressão*
        - repete *expressão* enquanto *condição* for verdadeira
1. `repeat`
    - `repeat` *expressão*
        - repete *expressão* para todo o sempre
            - a menos que um `break` seja executado
1. `break`
    - interrompe o *loop* e vai para a expressão seguinte
1. `next`
    - vai para a próxima iteração



## Outras Instruções de *Loop*

Um exemplo de *loop* com `while`

```{r, eval=FALSE}
resposta <- 0
while (resposta != 42)
{
  print("A resposta tem que ser 42")
  resposta <- readline(prompt = "Qual é a sua resposta?")
} 
```



## Outras Instruções de *Loop*

O mesmo *loop* com `repeat` e `break`

```{r, eval=FALSE}
repeat
{
  resposta <- readline(prompt = "Qual é a sua resposta?")
  if (resposta == 42)
      break
  print("A resposta tem que ser 42");
} 
```



## Outras Instruções de *Loop*

Um exemplo com `repeat`, `break` e `next`

```{r}
k <- 0
repeat {
    k <-  k + 1
    if (k > 10)
        break
    if (k %% 2 == 1)
        next
    print(k)
}
```



## Outras Instruções de *Loop*

Com a instrução `for `, o exemplo ficaria

```{r}
for (k in 1:10) {
    if (k %% 2 == 1)
        next
    print(k)
}
```





# Instruções de Execução Condicional



## Instruções de Execução Condicional

1. As instruções `if` e `else`
1. A função `ifelse()`
<!-- 1. A função `switch()` -->



## Instrução `if`

A instrução `if` serve para executar um trecho de código somente se uma condição 
(uma expressão em `R` que retorne um único valor lógico) for verdadeira.

A sintaxe da instrução `if` é

```{r, eval=FALSE}
if (condição) expressão
```

Se houver mais de a expressão, use `{}`

```{r, eval=FALSE}
if (condição) {expressão; ...; expressão}
```



## Instrução `if`

Assim como com a instrução `for`, quebrar a instrução em mais de uma linha 
geralmente aumenta a legibilidade do seu código.

```{r, eval=FALSE}
if (condição) 
    expressão

if (condição) {
    expressão
    ...
    expressão
}
```



## Instrução `if`

Tente executar o seguinte código:

```{r 18a, eval=F}
if (2 < 3) print("2 é menor que 3")
```



## Instrução `if`

Deve ter dado este resultado:

```{r 18a}
```



## Instrução `if`

Agora, tente executar o seguinte código:

```{r 18b, eval=F}
if (2 > 3) print("2 é maior que 3")
```



## Instrução `if`

Deve ter dado este resultado:

```{r 18b}
```



## Instrução `if`

Deve ter dado este resultado:

```{r 18b}
```

Sim, é isso aí: não gerou resultado nenhum.

Adivinha porquê?

Porque não executou código nenhum.



## Instruções `if` e `else`

As instruções `if` e `else` usadas em conjunto permitem executar ou um trecho 
de código se a condição for verdadeira ou outro trecho de código se a condição 
for falsa.

A sintaxe da instrução `if` é

```{r, eval=FALSE}
if (condição) expressão1 else expressão2
```

Se houver mais de uma expressão, use `{}`

```{r, eval=FALSE}
if (condição) {expressão; ...; expressão} else {expressão; ...; expressão} 
```



## Instruções `if` e `else`

Claro, quebrar a instrução em mais de uma linha geralmente aumenta a 
legibilidade do seu código.

Contudo há um **grande** restrição no uso da instrução `else` em uma linha 
diferente da linha da instrução `if`.

**ATENÇÃO**: Isso pode fazer o seu *script* dar um pau do qual você dificilmente 
desconfiará.

- Não diga que eu não avisei



## Instruções `if` e `else`

Vamos aprender por tentativa e erro.

Vamos tentar e **errar**.



## Instruções `if` e `else`

Tente executar o seguinte código:

```{r 18c, eval=F}
if (2 < 3) print("2 é menor que 3") else print("2 é maior que ou igual a 3")
```



## Instruções `if` e `else`

Deve ter dado o seguinte resultado:

```{r 18c}
```



## Instruções `if` e `else`

Ok.  Agora, tente executar o seguinte código:

```{r 18d, eval=F}
if (2 > 3) print("2 é maior que 3") else print("2 é menor que ou igual a 3")
```



## Instruções `if` e `else`

Deve ter dado o seguinte resultado:

```{r 18d}
```



## Instruções `if` e `else`

Legal.  Agora, vamos tentar separar esse `if` em mais de uma linha.

*Spoiler* de *GoT*: vai dar erro.

Tente executar o seguinte código:

```{r 18e, eval=F}
if (2 < 3) 
    print("2 é menor que 3") 
else 
    print("2 é maior que ou igual a 3")
```



## Instruções `if` e `else`

Deve ter dado o seguinte erro:

```{r 18e, warning=T, error=T}
```



## Instruções `if` e `else`

Agora, tente esta versão:

```{r 18f, eval=F}
if (2 < 3) {
    print("2 é menor que 3") 
} else {
    print("2 é maior que ou igual a 3")
}
```



## Instruções `if` e `else`

Deve ter dado este resultado:

```{r 18f}
```



## Instruções `if` e `else`

Só de sacanagem, vamos tentar esta versão:

```{r 18g, eval=F}
if (2 < 3) {
    print("2 é menor que 3") 
} 
else {
    print("2 é maior que ou igual a 3")
}
```



## Instruções `if` e `else`

Deve ter dado este erro:

```{r 18g, warning=TRUE, error=TRUE}
```



## Instruções `if` e `else`

O jeito mais seguro de executar a instrução `if` com a instrução `else` 
correspondente em uma outra linha é

```{r, eval=FALSE}
if (condição) {
    expressão
} else {
    expressão
}
```

Faça isso **sempre**.



## Instruções `if` e `else`

"Ok, Marcelo, eu prometo que eu vou fazer isso sempre."

"Mas você poderia explicar por que esse erro misterioso acontece?"

Claro que posso!

Que bom que vocês perguntaram!

=D



## Instruções `if` e `else`

Note que a instrução `if`, na realidade, é uma expressão!

```{r}
if (T) 2 else 3
if (F) 2 else 3
```



## Instruções `if` e `else`

Na verdade, dá para fazer isto:

```{r}
x <- (if (T) 2 else 3)
x
y <- (if (F) 2 else 3)
y
```



## Instruções `if` e `else`

Na verdade, dá para fazer até mesmo isto:

```{r}
x <- (if (T) 2)
x
y <- (if (F) 2)
y
```

E é aí que mora o problema!



## Instruções `if` e `else`

O `R` só procura por uma continuação de uma expressão na próxima linha se a 
expressão não parecer concluída.

Um `if` sem `else` faz sentido o suficiente para a expressão ser considerada 
completa até o final da linha, logo o `R` conclui que a expressão está completa.

Daí, o `R` não entende o porquê de a linha seguinte começar por um `else`, que, 
para ele, parece solto.

E isso não ocorre com a sintaxe segura.

Daí criar o costume de usar essa sintaxe sempre.

=)



## Função `ifelse()`

As instruções `if` e `else` são bem legais, mas só funcionam com um único valor 
lógico, e não com um vetor de lógicos.

```{r}
if (c(T, T, F, F)) 1 else 2
if (c(F, F, T, T)) 1 else 2
```



## Função `ifelse()`

Teria sido legal 

- se `if (c(T, T, F, F)) 1 else 2` retornasse `c(1, 1, 2, 2)` e 
- se `if (c(F, F, T, T)) 1 else 2` retornasse `c(2, 2, 1, 1)`

É aí que entra a função `ifelse()`

```{r}
ifelse(c(T, T, F, F), 1, 2)
ifelse(c(F, F, T, T), 1, 2)
```



## Função `ifelse()`

A sintaxe da função `ifelse()` é

```{r, eval=FALSE}
ifelse(vetor.lógico, vetor.valores.se.T, vetor.valores.se.F)
```

em que os vetores `vetor.lógico`, `vetor.valores.se.T` e `vetor.valores.se.F` 
têm que ter o mesmo comprimento ou então vão ser reciclados em função do 
comprimento de `vetor.lógico`.



<!-- ## Função `switch()` -->

<!-- A função `switch()` tem as seguintes sintaxes: -->

<!-- ```{r, eval=FALSE} -->
<!-- switch(expr, "valor_1" = expr_1, "valor_2" = expr_2, ...,"valor_n" = expr_n) -->

<!-- switch(expr, "valor_1" = expr_1, "valor_2" = expr_2, ...,"valor_n" = expr_n, expr_else) -->

<!-- switch(expr, expr_1, expr_2, ..., expr_n) -->
<!-- ``` -->

<!-- As duas primeiras sintaxes só funcionam se `expr` for do tipo texto. -->

<!-- A última sintaxe funciona se `expr` for de qualquer outro tipo que não texto. -->



<!-- ## Função `switch()` -->

<!-- As duas primeiras sintaxes só funcionam se `expr` for do tipo texto. -->

<!-- ```{r, eval=FALSE} -->
<!-- switch(expr, "valor_1" = expr_1, "valor_2" = expr_2, ...,"valor_n" = expr_n) -->

<!-- switch(expr, "valor_1" = expr_1, "valor_2" = expr_2, ...,"valor_n" = expr_n, expr_else) -->
<!-- ``` -->

<!-- - Nesse caso, o primeiro parâmetro não é nomeado e, opcionalmente, o último -->
<!-- parâmetro também pode não ser nomeado. -->
<!-- - Fora esses dois parâmetros, todos os demais têm que ser parâmetros nomeados. -->
<!-- - Caso o nome dos parâmetros sejam nomes válidos de variáveis, então as aspas -->
<!-- podem ser dispensadas. -->



<!-- ## Função `switch()` -->

<!-- As duas primeiras sintaxes só funcionam se `expr` for do tipo texto. -->

<!-- ```{r, eval=FALSE} -->
<!-- switch(expr, "valor_1" = expr_1, "valor_2" = expr_2, ...,"valor_n" = expr_n) -->

<!-- switch(expr, "valor_1" = expr_1, "valor_2" = expr_2, ...,"valor_n" = expr_n, expr_else) -->
<!-- ``` -->

<!-- 1. Se o valor de `expr` for igual a um dos nomes `valor_1`, `valor_2` etc. ou -->
<!-- `valor_n`, então `switch()` retornará o valor da expressão `expr_1`, `expr_2` -->
<!-- etc. ou `expr_n` -->
<!-- 1. Se o valor de `expr` não for igual a nenhum dos nomes `valor_1`, `valor_2` -->
<!-- etc. ou `valor_n`, então `switch()` procura por um último parâmetro `expr_else` -->
<!-- sem nome -->
<!--     1. Se houver, então `switch()` retorna o seu valor -->
<!--     1. Se não houver, então `switch()` retorna `NULL` -->



<!-- ## Função `switch()` -->

<!-- Exemplos: -->

<!-- ```{r} -->
<!-- opção <- "x" -->
<!-- switch(opção, x = 1, y = 2, z = 3, 4) -->
<!-- opção <- "y" -->
<!-- switch(opção, x = 1, y = 2, z = 3, 4) -->
<!-- ``` -->



<!-- ## Função `switch()` -->

<!-- Exemplos: -->

<!-- ```{r} -->
<!-- opção <- "z" -->
<!-- switch(opção, x = 1, y = 2, z = 3, 4) -->
<!-- opção <- "w" -->
<!-- switch(opção, x = 1, y = 2, z = 3, 4) -->
<!-- ``` -->



<!-- ## Função `switch()` -->

<!-- A última sintaxe funciona se `expr` for de qualquer outro tipo que não texto. -->

<!-- ```{r, eval=FALSE} -->
<!-- switch(expr, expr_1, expr_2, ..., expr_n) -->
<!-- ``` -->

<!-- 1. Se o tipo de `expr` não for inteiro, então ele é convertido a inteiro -->
<!-- 1. Se o valor de `expr` estiver entre 1 e (número de parâmetros - 1), então -->
<!-- `switch()` retorna o valor do parâmetro correspondente. -->
<!-- 1. Do contrário, `switch()` retorna `NULL` -->



<!-- ## Função `switch()` -->

<!-- Exemplos: -->

<!-- ```{r} -->
<!-- opção <- 1 -->
<!-- switch(opção, 10, 20, 30, 40) -->
<!-- opção <- 2 -->
<!-- switch(opção, 10, 20, 30, 40) -->
<!-- ``` -->



<!-- ## Função `switch()` -->

<!-- Exemplos: -->

<!-- ```{r} -->
<!-- opção <- 3 -->
<!-- switch(opção, 10, 20, 30, 40) -->
<!-- opção <- 4 -->
<!-- switch(opção, 10, 20, 30, 40) -->
<!-- ``` -->



<!-- ## Função `switch()` -->

<!-- Exemplos: -->

<!-- ```{r} -->
<!-- opção <- 0 -->
<!-- switch(opção, 10, 20, 30, 40) -->
<!-- opção <- -1 -->
<!-- switch(opção, 10, 20, 30, 40) -->
<!-- opção <- 200 -->
<!-- switch(opção, 10, 20, 30, 40) -->
<!-- ``` -->



<!-- ## Função `switch()` -->

<!-- Exemplos: -->

<!-- ```{r} -->
<!-- opção <- .5 -->
<!-- switch(opção, 10, 20, 30, 40) -->
<!-- opção <- .6 -->
<!-- switch(opção, 10, 20, 30, 40) -->
<!-- opção <- .9 -->
<!-- switch(opção, 10, 20, 30, 40) -->
<!-- opção <- 1.1 -->
<!-- switch(opção, 10, 20, 30, 40) -->
<!-- opção <- exp(1) -->
<!-- switch(opção, 10, 20, 30, 40) -->
<!-- ``` -->



<!-- ## Função `switch()` -->

<!-- Exemplos: -->

<!-- ```{r} -->
<!-- opção <- TRUE -->
<!-- switch(opção, 10, 20, 30, 40) -->
<!-- opção <- FALSE -->
<!-- switch(opção, 10, 20, 30, 40) -->
<!-- ``` -->



<!-- ## Função `switch()` -->

<!-- Exemplos: -->

<!-- ```{r} -->
<!-- opção <- "2"  # não há um "2" entre os parâmetros -->
<!-- switch(opção, x = 10, y = 20, z = 30, 40) -->
<!-- opção <- 2    # pega o segundo parâmetro, viz., "y" -->
<!-- switch(opção, x = 10, y = 20, z = 30, 40) -->
<!-- ``` -->



<!-- ## Função `switch()` -->

<!-- Exemplos: -->

<!-- ```{r} -->
<!-- opção <- "20"  # não há um "20" entre os parâmetros -->
<!-- switch(opção, x = 10, y = 20, z = 30, 40) -->
<!-- opção <- 20    # não há 21 parâmetros -->
<!-- switch(opção, x = 10, y = 20, z = 30, 40) -->
<!-- ``` -->



